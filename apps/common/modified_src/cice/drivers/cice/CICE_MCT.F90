      module CICE_MCT

      use ice_kinds_mod
      use ice_blocks, only : block, get_block, nx_block, ny_block
      use ice_constants, only: field_loc_center, field_type_scalar
      use ice_domain, only : nblocks, blocks_ice, halo_info
      use ice_domain_size, only : nx_global, ny_global !, block_size_x, block_size_y, max_blocks
      use ice_flux, only: sst, uocn, vocn
      use ice_state, only: aice,vice
      use ice_boundary, only: ice_HaloUpdate
      use ice_fileunits, only: ice_stdout, ice_stderr ! these might be the same

!  MCT framework for ROMS coupling
!
!  Componenent model registry.
!
      USE m_MCTWorld, ONLY : MCTWorld_init => init
      USE m_MCTWorld, ONLY : MCTWorld_clean => clean
!
!  Domain decomposition descriptor datatype and associated methods.
!
      USE m_GlobalSegMap, ONLY : GlobalSegMap
      USE m_GlobalSegMap, ONLY : GlobalSegMap_init => init
      USE m_GlobalSegMap, ONLY : GlobalSegMap_lsize => lsize
      USE m_GlobalSegMap, ONLY : GlobalSegMap_clean => clean
      USE m_GlobalSegMap, ONLY : GlobalSegMap_Ordpnts => OrderedPoints
!
!  Field storage data types and associated methods.
!
      USE m_AttrVect, ONLY : AttrVect
      USE m_AttrVect, ONLY : AttrVect_init => init
      USE m_AttrVect, ONLY : AttrVect_zero => zero
      USE m_AttrVect, ONLY : AttrVect_clean => clean
      USE m_AttrVect, ONLY : AttrVect_indxR => indexRA
      USE m_AttrVect, ONLY : AttrVect_importRAttr => importRAttr
      USE m_AttrVect, ONLY : AttrVect_exportRAttr => exportRAttr
!
!  Intercomponent communitcations scheduler.
!
      USE m_Router, ONLY : Router
      USE m_Router, ONLY : Router_init => init
      USE m_Router, ONLY : Router_clean => clean

      USE m_Transfer, ONLY : MCT_Send => send
      USE m_Transfer, ONLY : MCT_Recv => recv

      USE ice_communicate, ONLY: MPI_COMM_ICE, nprocs, my_task, master_task

!

      implicit none
      private
      public  :: init_mct,                  &
                 CICE_MCT_coupling,         &
                 GSMapCICE,                 &
                 cice2ocn_AV,               &
                 ocn2cice_AV,               &
                 CICEtoROMS

      save

      real (kind=dbl_kind) ::   TimeInterval = 7200.0
      real (kind=dbl_kind) ::   tcoupling = 0.0

   integer (int_kind), public :: &
      CICEid,                   &
      OCNid,                    &
      Nmodels

!  MCT coupling variables
   type(GlobalSegMap) :: GSMapCICE         ! GloabalSegMap variables
   type(AttrVect)     :: cice2ocn_AV       ! AttrVect variables
   type(AttrVect)     :: ocn2cice_AV
   type(Router)       :: CICEtoROMS        ! Router variables

!=======================================================================

      contains

 subroutine init_mct
!
!  MCT interface initialization
!
   include 'mpif.h'   ! MPI Fortran include file

   integer, pointer :: start(:), length(:)
   integer :: Asize,Istr,Jstr !,j
   character (len=240) :: importList, exportList


    integer     :: ilo_glob, j_glob
    integer     :: i, j, iblk, n, gi
    integer     :: lsize,gsize
    integer     :: ier
    integer     :: ilo, ihi, jlo, jhi ! beginning and end of physical domain
    type(block) :: this_block         ! block information for current block

!
!  Initialize MCT coupled model registry.
!
   CALL MCTWorld_init (Nmodels, MPI_COMM_WORLD, MPI_COMM_ICE, CICEid)
   WRITE (ice_stdout,*) ' CICE: MCTWorld_init called'


!-------------------------------------------------------------------

! Build the CICE grid numbering for MCT
! NOTE:  Numbering scheme is: West to East and South to North
! starting at south pole.  Should be the same as what's used
! in SCRIP

! number the local grid

    n=0
    do iblk = 1, nblocks
       this_block = get_block(blocks_ice(iblk),iblk)
       ilo = this_block%ilo
       ihi = this_block%ihi
       jlo = this_block%jlo
       jhi = this_block%jhi
       n = n + (1+jhi-jlo)
    enddo
    lsize = n
    WRITE (ice_stdout,*) ' CICE: lsize=', lsize
    allocate(start(lsize))
    allocate(length(lsize))
    n=0
    do iblk = 1, nblocks
       this_block = get_block(blocks_ice(iblk),iblk)
       ilo = this_block%ilo
       ihi = this_block%ihi
       jlo = this_block%jlo
       jhi = this_block%jhi
       do j = jlo, jhi
          n = n+1
          ilo_glob = this_block%i_glob(ilo)
          j_glob = this_block%j_glob(j)
          start(n) = (j_glob-1)*nx_global + ilo_glob
          length(n) = 1+ihi-ilo
       enddo
    enddo

!  Use grid decomposition to initialize global segmentation map
   WRITE (ice_stdout,*) ' CICE: GlobalSegMap_init'
   call GlobalSegMap_init(GSMapCICE, start, length, 0, MPI_COMM_ICE, CICEid)
   Asize=GlobalSegMap_lsize(GSMapCICE, MPI_COMM_ICE)


!  Initialize import/export attribute vectors
   importList='SST:Ubar'
   exportList='AICE:VICE'

   WRITE (ice_stdout,*) ' CICE: AttrVect_init, Asize=', Asize
   call AttrVect_init(ocn2cice_AV, rList=importList, lsize=Asize)
   call AttrVect_zero(ocn2cice_AV)
   call AttrVect_init(cice2ocn_AV, rlist=exportList, lsize=Asize)
   call AttrVect_zero(cice2ocn_AV)


!  Initialize router to ROMS
   WRITE (ice_stdout,*) ' CICE: Router_init'
   call Router_init (OCNid, GSMapCICE, MPI_COMM_ICE, CICEtoROMS)
   WRITE (ice_stdout,*) ' CICE: Router_init. Done.'

 end subroutine init_mct

!***********************************************************************


      subroutine CICE_MCT_coupling(time,dt)
         use ice_grid, only: HTN, dxu
         real(kind=dbl_kind), intent(in) :: time,dt
         real(kind=dbl_kind), pointer :: avdata(:)
         integer     :: ilo, ihi, jlo, jhi ! beginning and end of physical domain
         type(block) :: this_block         ! block information for current block
         integer     :: i,j,Asize,iblk,n

!        ***********************************
!             ROMS coupling
!        ***********************************
!
         tcoupling = tcoupling + dt
         IF (tcoupling >= TimeInterval) THEN
            IF (my_task == master_task) THEN
                write(ice_stdout,*) '*****************************************************'
                write(ice_stdout,*) 'CICE - Ocean: coupling routine called from CICE'
                write(ice_stdout,*) 'time = ', time
                write(ice_stdout,*) 'dt = ', dt
                write(ice_stdout,*) '*****************************************************'
            END IF
            Asize=GlobalSegMap_lsize(GSMapCICE, MPI_COMM_ICE)
            allocate(avdata(Asize))
            avdata=0.0

            ! Exporting aice
            n = 0
            do iblk = 1, nblocks
               this_block = get_block(blocks_ice(iblk),iblk)
               ilo = this_block%ilo
               ihi = this_block%ihi
               jlo = this_block%jlo
               jhi = this_block%jhi
               do j = jlo, jhi
                  do i = ilo, ihi
                      n = n+1
                      avdata(n)=aice(i,j,iblk)
                  enddo
               enddo
            enddo
            write(ice_stdout,*) 'CICE rank ', my_task, ' sending aice field (max/min): ', maxval(avdata), ' ', minval(avdata)
            CALL AttrVect_importRAttr(cice2ocn_AV, 'AICE', avdata)
            !CALL MCT_Send(cice2ocn_AV, CICEtoROMS)

            ! Exporting vice
            n = 0
            do iblk = 1, nblocks
               this_block = get_block(blocks_ice(iblk),iblk)
               ilo = this_block%ilo
               ihi = this_block%ihi
               jlo = this_block%jlo
               jhi = this_block%jhi
               do j = jlo, jhi
                  do i = ilo, ihi
                      n = n+1
                      avdata(n)=vice(i,j,iblk)
                  enddo
               enddo
            enddo
            write(ice_stdout,*) 'CICE rank ', my_task, ' sending vice field (max/min): ', maxval(avdata), ' ', minval(avdata)
            CALL AttrVect_importRAttr(cice2ocn_AV, 'VICE', avdata)
            CALL MCT_Send(cice2ocn_AV, CICEtoROMS)


            CALL MCT_Recv(ocn2cice_AV, CICEtoROMS)
            write(ice_stdout,*) 'CICE - Ocean: CICE Received data'
!
!
            CALL AttrVect_exportRAttr(ocn2cice_AV, 'SST', avdata)

            write(ice_stdout,*) 'CICE rank ', my_task, ' setting the sst field (max/min): ', maxval(avdata), ' ', minval(avdata)
            n = 0
            do iblk = 1, nblocks
               this_block = get_block(blocks_ice(iblk),iblk)
               ilo = this_block%ilo
               ihi = this_block%ihi
               jlo = this_block%jlo
               jhi = this_block%jhi
               do j = jlo, jhi
                  do i = ilo, ihi
                      n = n+1
                      sst(i,j,iblk)=avdata(n)
                  enddo
               enddo
            enddo
            call ice_HaloUpdate (sst, halo_info, field_loc_center, field_type_scalar)


! recieve ocean currents and interpolate to B grid
            CALL AttrVect_exportRAttr(ocn2cice_AV, 'Ubar', avdata)

            write(ice_stdout,*) 'CICE rank ', my_task, ' setting the U (uocn) field(max/min): ', maxval(avdata), ' ', minval(avdata)
            n = 0
            do iblk = 1, nblocks
               this_block = get_block(blocks_ice(iblk),iblk)
               ilo = this_block%ilo
               ihi = this_block%ihi
               jlo = this_block%jlo
               jhi = this_block%jhi
               do j = jlo, jhi
                  do i = ilo, ihi
                      n = n+1
                      uocn(i,j,iblk)=avdata(n)
                  enddo
               enddo
            enddo

            ! unfortunately need to cal ice_HaloUpdate twice for the
            ! interpolations sake (ihi+1)
            call ice_HaloUpdate (uocn, halo_info, field_loc_center, field_type_scalar)
            
!this should really be a function I think.
!            do iblk = 1, nblocks
!               this_block = get_block(blocks_ice(iblk),iblk)
!               ilo = this_block%ilo
!               ihi = this_block%ihi
!               jlo = this_block%jlo
!               jhi = this_block%jhi
!               do j = jlo, jhi
!                  do i = ilo, ihi
!                      uocn(i,j,iblk) =                                                 &
!     &                        0.5*(uocn(i,j,iblk)*HTN(i,j,iblk)            &
!     &                             +uocn(i+1,j,iblk)*HTN(i+1,j,iblk))  &
!     &                           /(dxu(i,j,iblk))
!                  enddo
!               enddo
!            enddo

!            call ice_HaloUpdate (uocn, halo_info, field_loc_center, field_type_scalar)

            tcoupling = 0.0
         END IF


!        ***********************************

      end subroutine

!      function interp_U_C_to_B(C) result(B)
!          use ice_grid, only: HTN, dxu
!          ! input array is called C, output array B, for C and B grid...
!          real*8, intent(in),  dimension(:,:)                  :: C
!          real*8, dimension(size(C,1),size(C,2))  :: B
!          integer :: n
! 
!          !HTN - length of northern side of T-cell
!          !dxu - width through the middle of U-cell (B-grid)
!          do n = 1, size(C,1)-1, 1
!              B(n,:) = 0.5*(C(n,:)*HTN(n,:)+C(n+1,:)*HTN(n+1,:))/(dxu(n,:))
!          end do        
!      end function interp_U_C_to_B
!  
!      function interp_V_C_to_B(C) result(B)
!          use ice_grid, only: HTE, dyu
!          real*8, intent(in),  dimension(:,:)                 :: C
!          real*8, dimension(size(C,1),size(C,2)) :: B
!          integer :: n          
!
!          !HTE - length of eastern side of T-cell
!          !dxy - width through the middle of U-cell (B-grid)
!          do n = 1, size(C,2)-1, 1
!              B(:,n) = 0.5*(C(:,n)*HTE(:,n)+C(:,n+1)*HTE(:,n+1))/(dyu(:,n)) 
!          end do
!          
!      end function interp_V_C_to_B


      end module
